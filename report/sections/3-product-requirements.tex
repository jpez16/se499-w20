\section{Engineering a solution}
Now that a concrete way to determine a habit loop has been identified, the next step is to create a set of requirements for our solution. We learned from our initial user study that our solution must satisfy the following:

\begin{enumerate}
    \item Have low barrier of entry
    \item Educate users on the habit loop
    \item Make the habit loop discovery process user friendly
    \item Make tracking habits low effort
\end{enumerate}

\subsection{Scope}
Next we narrowed down the problem to only include creating habits that best suit the Habit Loop methodology. The constraints are:


\begin{itemize}
    \item Must be applied to change and replace an old undesirable habit
    \item Must be able to include a cue, a routine and a reward
    \item Habit goals are user-defined
\end{itemize}

In a future expansion of this project, it may be worthwhile to re-evaluate the scope. With that being said, there was a general consensus that adding more features for the sake of it would be detrimental, and potentially drift away from the main idea of the habit loop. Later in this document some potential expansions are discussed.

\subsection{Product Requirements}
After deciding to utilize both high-level objectives and scoping, SE463 principles were applied to develop a finite set of product requirements. These requirements are listed below:
\subsubsection{Education}
Users can read about the cue routine reward methodology, with examples and explanations for each step.
\subsubsection{Habit Management}
The user can see their “finalized habits” and their “to be determined/in progress habits”:

\begin{enumerate}
    \item Finalized $\implies$ The user has discovered the cue, routine, and reward already
    \item In Progress $\implies$ The user is still experimenting with the cue, routine, reward
\end{enumerate}
\subsubsection{Discovering new Habits}    
The user can enter an interface flow to add a new habit
    \begin{enumerate}
        \item The user can add a routine
        \item The user can track details to discover their cue 
            \begin{enumerate}
                \item The user is prompt with six cue questions that require a short text response
                    \begin{enumerate}
                        \item Location: Where are you? \textit{Ex: At home, in my bedroom}
                        \item Time: What time of day is it? \textit{Ex: Around 2-3pm}
                        \item Mood: What is your emotional state? \textit{Ex: Confused \& anxious}
                        \item Thoughts: What are you thinking? \textit{Ex: Thinking about what deadlines I have coming up}
                        \item Surrounding people: Who is nearby? \textit{Ex: My co-workers}
                        \item Immediately preceding action: What did you do right before? \textit{Ex: I ate a meal}
                    \end{enumerate}
                \item The user can add or save instances of the above answers to the cue questions (independent of each other; each records a response to all six questions)
                \item The user can view a compilation of their cue questions graphically:
                    \begin{enumerate}
                        \item Location – Displayed in a list
                        \item Time - Displayed in a calendar
                        \item Mood - Displayed in a list
                        \item Thoughts - Displayed in a list
                        \item Surrounding people - Displayed in a list
                        \item Immediately preceding action - Displayed in a list
                    \end{enumerate}
                \item The user can then select one of their previously saved cues (or a combination of multiple cues) as the final cue for their particular habit
            \end{enumerate}
        \item The user can experiment with rewards:
        \begin{enumerate}
            \item The user can track or add a theoretical reward, composed of a “craving” and a “reward”:
            \begin{enumerate}
                \item User is presented with two questions to add a theoretical reward, along with short text response boxes:
                \begin{enumerate}
                    \item Craving: What craving do you think you want? \textit{Ex: I want to socialize}
                    \item What will you use to fulfill the craving? \textit{Ex: Talk to my co-workers}
                \end{enumerate}
                \item The user can save or add multiple craving theories at first; then fill in the others later. This is for the case where a user may have a multiple theories as to what they actually want, but unsure of what to replace it with yet.
                \item If the craving and the reward are both filled out, the user can indicate if their test was successful or had failed
                \item Successful rewards are indicated or highlighted, while failed rewards are shown greyed out or smaller font
                \item The user can select one of their inputted rewards as the final success for their habit
            \end{enumerate}
            \item The user can add additional notes for things not mentioned above
        \end{enumerate}
        \item Once a user has added their cue and reward, the user can turn them into a new habit instance, such that:
        \begin{enumerate}
            \item The cue $\implies$ cue
            \item The reward craving $\implies$ reward
            \item The reward fulfillment action $\implies$ reward
        \end{enumerate}
        \item The user can see the plan statement when they view their habit from the app’s main screen:
        \begin{enumerate}
            \item The user needs to write this plan with a large amount of intention
            \item Thus, forcing them to re-type their plan as a sentence
            \begin{enumerate}
                \item Type out your cue, routine and reward to continue! “When \textit{cue}, I will \textit{routine}, so that I \textit{reward}"
            \end{enumerate}
        \end{enumerate}
    \end{enumerate}
    It should be important to note that these requirements are \textit{not} a design specification, which comes after feature requirements are finalized.




